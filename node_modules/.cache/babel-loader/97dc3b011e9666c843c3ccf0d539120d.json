{"ast":null,"code":"var debug = require('debug')('koa-router');\n\nvar pathToRegExp = require('path-to-regexp');\n\nvar uri = require('urijs');\n\nmodule.exports = Layer;\n/**\n * Initialize a new routing Layer with given `method`, `path`, and `middleware`.\n *\n * @param {String|RegExp} path Path string or regular expression.\n * @param {Array} methods Array of HTTP verbs.\n * @param {Array} middleware Layer callback/middleware or series of.\n * @param {Object=} opts\n * @param {String=} opts.name route name\n * @param {String=} opts.sensitive case sensitive (default: false)\n * @param {String=} opts.strict require the trailing slash (default: false)\n * @returns {Layer}\n * @private\n */\n\nfunction Layer(path, methods, middleware, opts) {\n  this.opts = opts || {};\n  this.name = this.opts.name || null;\n  this.methods = [];\n  this.paramNames = [];\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n  methods.forEach(function (method) {\n    var l = this.methods.push(method.toUpperCase());\n\n    if (this.methods[l - 1] === 'GET') {\n      this.methods.unshift('HEAD');\n    }\n  }, this); // ensure middleware is a function\n\n  this.stack.forEach(function (fn) {\n    var type = typeof fn;\n\n    if (type !== 'function') {\n      throw new Error(methods.toString() + \" `\" + (this.opts.name || path) + \"`: `middleware` \" + \"must be a function, not `\" + type + \"`\");\n    }\n  }, this);\n  this.path = path;\n  this.regexp = pathToRegExp(path, this.paramNames, this.opts);\n  debug('defined route %s %s', this.methods, this.opts.prefix + this.path);\n}\n\n;\n/**\n * Returns whether request `path` matches route.\n *\n * @param {String} path\n * @returns {Boolean}\n * @private\n */\n\nLayer.prototype.match = function (path) {\n  return this.regexp.test(path);\n};\n/**\n * Returns map of URL parameters for given `path` and `paramNames`.\n *\n * @param {String} path\n * @param {Array.<String>} captures\n * @param {Object=} existingParams\n * @returns {Object}\n * @private\n */\n\n\nLayer.prototype.params = function (path, captures, existingParams) {\n  var params = existingParams || {};\n\n  for (var len = captures.length, i = 0; i < len; i++) {\n    if (this.paramNames[i]) {\n      var c = captures[i];\n      params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;\n    }\n  }\n\n  return params;\n};\n/**\n * Returns array of regexp url path captures.\n *\n * @param {String} path\n * @returns {Array.<String>}\n * @private\n */\n\n\nLayer.prototype.captures = function (path) {\n  if (this.opts.ignoreCaptures) return [];\n  return path.match(this.regexp).slice(1);\n};\n/**\n * Generate URL for route using given `params`.\n *\n * @example\n *\n * ```javascript\n * var route = new Layer(['GET'], '/users/:id', fn);\n *\n * route.url({ id: 123 }); // => \"/users/123\"\n * ```\n *\n * @param {Object} params url parameters\n * @returns {String}\n * @private\n */\n\n\nLayer.prototype.url = function (params, options) {\n  var args = params;\n  var url = this.path.replace(/\\(\\.\\*\\)/g, '');\n  var toPath = pathToRegExp.compile(url);\n  var replaced;\n\n  if (typeof params != 'object') {\n    args = Array.prototype.slice.call(arguments);\n\n    if (typeof args[args.length - 1] == 'object') {\n      options = args[args.length - 1];\n      args = args.slice(0, args.length - 1);\n    }\n  }\n\n  var tokens = pathToRegExp.parse(url);\n  var replace = {};\n\n  if (args instanceof Array) {\n    for (var len = tokens.length, i = 0, j = 0; i < len; i++) {\n      if (tokens[i].name) replace[tokens[i].name] = args[j++];\n    }\n  } else if (tokens.some(token => token.name)) {\n    replace = params;\n  } else {\n    options = params;\n  }\n\n  replaced = toPath(replace);\n\n  if (options && options.query) {\n    var replaced = new uri(replaced);\n    replaced.search(options.query);\n    return replaced.toString();\n  }\n\n  return replaced;\n};\n/**\n * Run validations on route named parameters.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', function (id, ctx, next) {\n *     ctx.user = users[id];\n *     if (!user) return ctx.status = 404;\n *     next();\n *   })\n *   .get('/users/:user', function (ctx, next) {\n *     ctx.body = ctx.user;\n *   });\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Layer}\n * @private\n */\n\n\nLayer.prototype.param = function (param, fn) {\n  var stack = this.stack;\n  var params = this.paramNames;\n\n  var middleware = function (ctx, next) {\n    return fn.call(this, ctx.params[param], ctx, next);\n  };\n\n  middleware.param = param;\n  var names = params.map(function (p) {\n    return p.name;\n  });\n  var x = names.indexOf(param);\n\n  if (x > -1) {\n    // iterate through the stack, to figure out where to place the handler fn\n    stack.some(function (fn, i) {\n      // param handlers are always first, so when we find an fn w/o a param property, stop here\n      // if the param handler at this part of the stack comes after the one we are adding, stop here\n      if (!fn.param || names.indexOf(fn.param) > x) {\n        // inject this param handler right before the current item\n        stack.splice(i, 0, middleware);\n        return true; // then break the loop\n      }\n    });\n  }\n\n  return this;\n};\n/**\n * Prefix route path.\n *\n * @param {String} prefix\n * @returns {Layer}\n * @private\n */\n\n\nLayer.prototype.setPrefix = function (prefix) {\n  if (this.path) {\n    this.path = prefix + this.path;\n    this.paramNames = [];\n    this.regexp = pathToRegExp(this.path, this.paramNames, this.opts);\n  }\n\n  return this;\n};\n/**\n * Safe decodeURIComponent, won't throw any error.\n * If `decodeURIComponent` error happen, just return the original value.\n *\n * @param {String} text\n * @returns {String} URL decode original string.\n * @private\n */\n\n\nfunction safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch (e) {\n    return text;\n  }\n}","map":{"version":3,"names":["debug","require","pathToRegExp","uri","module","exports","Layer","path","methods","middleware","opts","name","paramNames","stack","Array","isArray","forEach","method","l","push","toUpperCase","unshift","fn","type","Error","toString","regexp","prefix","prototype","match","test","params","captures","existingParams","len","length","i","c","safeDecodeURIComponent","ignoreCaptures","slice","url","options","args","replace","toPath","compile","replaced","call","arguments","tokens","parse","j","some","token","query","search","param","ctx","next","names","map","p","x","indexOf","splice","setPrefix","text","decodeURIComponent","e"],"sources":["/Users/zen/Desktop/Backstage-exercise/node_modules/koa-router/lib/layer.js"],"sourcesContent":["var debug = require('debug')('koa-router');\nvar pathToRegExp = require('path-to-regexp');\nvar uri = require('urijs');\n\nmodule.exports = Layer;\n\n/**\n * Initialize a new routing Layer with given `method`, `path`, and `middleware`.\n *\n * @param {String|RegExp} path Path string or regular expression.\n * @param {Array} methods Array of HTTP verbs.\n * @param {Array} middleware Layer callback/middleware or series of.\n * @param {Object=} opts\n * @param {String=} opts.name route name\n * @param {String=} opts.sensitive case sensitive (default: false)\n * @param {String=} opts.strict require the trailing slash (default: false)\n * @returns {Layer}\n * @private\n */\n\nfunction Layer(path, methods, middleware, opts) {\n  this.opts = opts || {};\n  this.name = this.opts.name || null;\n  this.methods = [];\n  this.paramNames = [];\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n\n  methods.forEach(function(method) {\n    var l = this.methods.push(method.toUpperCase());\n    if (this.methods[l-1] === 'GET') {\n      this.methods.unshift('HEAD');\n    }\n  }, this);\n\n  // ensure middleware is a function\n  this.stack.forEach(function(fn) {\n    var type = (typeof fn);\n    if (type !== 'function') {\n      throw new Error(\n        methods.toString() + \" `\" + (this.opts.name || path) +\"`: `middleware` \"\n        + \"must be a function, not `\" + type + \"`\"\n      );\n    }\n  }, this);\n\n  this.path = path;\n  this.regexp = pathToRegExp(path, this.paramNames, this.opts);\n\n  debug('defined route %s %s', this.methods, this.opts.prefix + this.path);\n};\n\n/**\n * Returns whether request `path` matches route.\n *\n * @param {String} path\n * @returns {Boolean}\n * @private\n */\n\nLayer.prototype.match = function (path) {\n  return this.regexp.test(path);\n};\n\n/**\n * Returns map of URL parameters for given `path` and `paramNames`.\n *\n * @param {String} path\n * @param {Array.<String>} captures\n * @param {Object=} existingParams\n * @returns {Object}\n * @private\n */\n\nLayer.prototype.params = function (path, captures, existingParams) {\n  var params = existingParams || {};\n\n  for (var len = captures.length, i=0; i<len; i++) {\n    if (this.paramNames[i]) {\n      var c = captures[i];\n      params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;\n    }\n  }\n\n  return params;\n};\n\n/**\n * Returns array of regexp url path captures.\n *\n * @param {String} path\n * @returns {Array.<String>}\n * @private\n */\n\nLayer.prototype.captures = function (path) {\n  if (this.opts.ignoreCaptures) return [];\n  return path.match(this.regexp).slice(1);\n};\n\n/**\n * Generate URL for route using given `params`.\n *\n * @example\n *\n * ```javascript\n * var route = new Layer(['GET'], '/users/:id', fn);\n *\n * route.url({ id: 123 }); // => \"/users/123\"\n * ```\n *\n * @param {Object} params url parameters\n * @returns {String}\n * @private\n */\n\nLayer.prototype.url = function (params, options) {\n  var args = params;\n  var url = this.path.replace(/\\(\\.\\*\\)/g, '');\n  var toPath = pathToRegExp.compile(url);\n  var replaced;\n\n  if (typeof params != 'object') {\n    args = Array.prototype.slice.call(arguments);\n    if (typeof args[args.length - 1] == 'object') {\n      options = args[args.length - 1];\n      args = args.slice(0, args.length - 1);\n    }\n  }\n\n  var tokens = pathToRegExp.parse(url);\n  var replace = {};\n\n  if (args instanceof Array) {\n    for (var len = tokens.length, i=0, j=0; i<len; i++) {\n      if (tokens[i].name) replace[tokens[i].name] = args[j++];\n    }\n  } else if (tokens.some(token => token.name)) {\n    replace = params;\n  } else {\n    options = params;\n  }\n\n  replaced = toPath(replace);\n\n  if (options && options.query) {\n    var replaced = new uri(replaced)\n    replaced.search(options.query);\n    return replaced.toString();\n  }\n\n  return replaced;\n};\n\n/**\n * Run validations on route named parameters.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', function (id, ctx, next) {\n *     ctx.user = users[id];\n *     if (!user) return ctx.status = 404;\n *     next();\n *   })\n *   .get('/users/:user', function (ctx, next) {\n *     ctx.body = ctx.user;\n *   });\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.param = function (param, fn) {\n  var stack = this.stack;\n  var params = this.paramNames;\n  var middleware = function (ctx, next) {\n    return fn.call(this, ctx.params[param], ctx, next);\n  };\n  middleware.param = param;\n\n  var names = params.map(function (p) {\n    return p.name;\n  });\n\n  var x = names.indexOf(param);\n  if (x > -1) {\n    // iterate through the stack, to figure out where to place the handler fn\n    stack.some(function (fn, i) {\n      // param handlers are always first, so when we find an fn w/o a param property, stop here\n      // if the param handler at this part of the stack comes after the one we are adding, stop here\n      if (!fn.param || names.indexOf(fn.param) > x) {\n        // inject this param handler right before the current item\n        stack.splice(i, 0, middleware);\n        return true; // then break the loop\n      }\n    });\n  }\n\n  return this;\n};\n\n/**\n * Prefix route path.\n *\n * @param {String} prefix\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.setPrefix = function (prefix) {\n  if (this.path) {\n    this.path = prefix + this.path;\n    this.paramNames = [];\n    this.regexp = pathToRegExp(this.path, this.paramNames, this.opts);\n  }\n\n  return this;\n};\n\n/**\n * Safe decodeURIComponent, won't throw any error.\n * If `decodeURIComponent` error happen, just return the original value.\n *\n * @param {String} text\n * @returns {String} URL decode original string.\n * @private\n */\n\nfunction safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch (e) {\n    return text;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}